import AppKit
import OSLog

import Element
import Output

private let logger = Logger(subsystem: #fileID, category: "Access")

/// Accessibility context.
@AccessActor
public final class Access {
    /// System-wide element.
    internal let system: Element
    /// Active application.
    internal var application: Element?
    /// Process identifier of the active application.
    internal var processIdentifier: pid_t = 0
    /// Active application observer.
    internal var observer: ElementObserver?
    /// Entity with user focus.
    internal var focus: AccessFocus?
    /// Trigger to refocus when the frontmost application changes.
    internal var refocusTrigger: NSKeyValueObservation?

    /// The delegate to inform about important events
    public weak var delegate: (any AccessDelegate)?

    /// Initializes the accessibility framework.
    public init?() async {
        guard await Element.confirmProcessTrustedStatus() else {
            return nil
        }
        system = await Element()
        Task {[weak self] in
            while let self = self {
                var eventIterator = await self.observer?.eventStream.makeAsyncIterator()
                while let event = await eventIterator?.next() {
                    await handleEvent(event)
                }
                try? await Task.sleep(nanoseconds: 100_000_000)
            }
        }
        await refocus(processIdentifier: NSWorkspace.shared.frontmostApplication?.processIdentifier)
        refocusTrigger = NSWorkspace.shared.observe(\.frontmostApplication, options: .new) {[weak self] (_, value) in
            logger.info("Refocused!")
            guard let runningApplication = value.newValue, let runningApplication else {
                return
            }
            let processIdentifier = runningApplication.processIdentifier
            Task { [self] in
                await self?.refocus(processIdentifier: processIdentifier)
            }
        }
    }

    /// Sets the response timeout of the accessibility framework.
    /// - Parameter seconds: Time in seconds.
    public func setTimeout(seconds: Float) async {
        do {
            try await system.setTimeout(seconds: seconds)
        } catch {
            await handleError(error)
        }
    }

    /// Returns all actionable elements of the focused application
    @MainActor
    public func actionableElements() async throws -> [ActionableElement]? {
        guard let application = await application else {
            return nil
        }
        return try await application.getActionableElements()
    }

    /// Returns a snapshot of the current accessibility state
    @MainActor
    public func takeAccessSnapshot() async throws -> AccessSnapshot? {
        // TODO: consider using AccessGenericReader to get extra context for elements

        // Get actionable elements
        guard let elements = try await actionableElements() else {
            logger.warning("No elements found")
            return nil
        }

        // Get the app name and focused element
        let appName = try await application?.getAttribute(.title) as? String
        let focusElement = await focus

        return AccessSnapshot(
            focusedAppName: appName,
            focus: focusElement,
            actionableItems: elements
        )
    }

    /// Handles events generated by the application element.
    /// - Parameter event: Generated event.
    internal func handleEvent(_ event: ElementEvent) async {
        do {
            switch event.notification {
            case .applicationDidAnnounce:
                if let announcement = event.payload?[.announcement] as? String {
                    logger.info("Application announced: \(announcement)")
                }
            case .elementDidAppear:
                guard focus == nil else {
                    try await observer?.unsubscribe(from: .elementDidAppear)
                    break
                }
                await refocus(processIdentifier: processIdentifier)
                if self.focus != nil {
                    try await observer?.unsubscribe(from: .elementDidAppear)
                }
            case .elementDidDisappear:
                guard event.subject == focus?.entity.element else {
                    break
                }
                let entity = try await AccessEntity(for: event.subject)
                guard let isFocusableAncestor = try await focus?.entity.isInFocusGroup(of: entity),
                      !isFocusableAncestor else {
                    break
                }
                focus = nil
                await refocus(processIdentifier: self.processIdentifier)
            case .elementDidGetFocus:
                guard event.subject != focus?.entity.element else {
                    break
                }
                let newFocus = try await AccessFocus(on: event.subject)
                guard let oldFocus = focus, try await !oldFocus.entity.isInFocusGroup(of: newFocus.entity) else {
                    break
                }
                self.focus = newFocus
//                await readFocus()
            default:
                fatalError("Received an unexpected event notification \(event.notification)")
            }
        } catch {
            await handleError(error)
        }
    }

    /// Handles errors returned by the Element module.
    /// - Parameter error: Error to handle.
    internal func handleError(_ error: any Error) async {
        guard let error = error as? ElementError else {
            fatalError("Unexpected error \(error)")
        }
        switch error {
        case .apiDisabled:
            let content = [OutputSemantic.apiDisabled]
            await Output.shared.convey(content)
        case .invalidElement:
            await refocus(processIdentifier: processIdentifier)
        case .notImplemented:
            let content = [OutputSemantic.notAccessible]
            await Output.shared.convey(content)
        case .timeout:
            let content = [OutputSemantic.timeout]
            await Output.shared.convey(content)
        default:
            logger.warning("Unexpected error \(error, privacy: .public)")
            return
        }
    }
}
