import AppKit
import OSLog

import Element
import Output

private let logger = Logger(subsystem: #fileID, category: "Access")

/// Accessibility context.
@AccessActor
public final class Access {
    /// System-wide element.
    internal let system: Element
    /// Active application.
    internal var application: Element?
    /// Process identifier of the active application.
    internal var processIdentifier: pid_t = 0
    /// Active application observer.
    internal var observer: ElementObserver?
    /// Entity with user focus.
    internal var focus: AccessFocus?
    /// Trigger to refocus when the frontmost application changes.
    internal var refocusTrigger: NSKeyValueObservation?
    /// Number of times refocus has failed. ``Access`` will stop trying after 5 tries
    internal var refocusFailedCount: Int = 0

    /// The delegate to inform about important events
    public weak var delegate: (any AccessDelegate)?

    /// Initializes the accessibility framework.
    public init?() async {
        guard await Element.confirmProcessTrustedStatus() else {
            return nil
        }
        system = await Element()
        Task {[weak self] in
            while let self = self {
                var eventIterator = await self.observer?.eventStream.makeAsyncIterator()
                while let event = await eventIterator?.next() {
                    await handleEvent(event)
                }
                try? await Task.sleep(nanoseconds: 100_000_000)
            }
        }
        await refocus(processIdentifier: NSWorkspace.shared.frontmostApplication?.processIdentifier)
        refocusTrigger = NSWorkspace.shared.observe(\.frontmostApplication, options: .new) {[weak self] (_, value) in
//            logger.info("Refocused!")
            guard let runningApplication = value.newValue, let runningApplication else {
                return
            }
            let processIdentifier = runningApplication.processIdentifier
            Task { [self] in
                await self?.refocus(processIdentifier: processIdentifier)
            }
        }
    }

    /// Sets the response timeout of the accessibility framework.
    /// - Parameter seconds: Time in seconds.
    public func setTimeout(seconds: Float) async {
        do {
            try await system.setTimeout(seconds: seconds)
        } catch {
            await handleError(error)
        }
    }

    /// Handles events generated by the application element.
    /// - Parameter event: Generated event.
    internal func handleEvent(_ event: ElementEvent) async {
        do {
            switch event.notification {
            case .applicationDidAnnounce:
                if let announcement = event.payload?[.announcement] as? String {
                    logger.info("Application announced: \(announcement)")
                }
            case .elementDidAppear:
                guard focus == nil else {
                    try await observer?.unsubscribe(from: .elementDidAppear)
                    break
                }
                await refocus(processIdentifier: processIdentifier)
                if self.focus != nil {
                    try await observer?.unsubscribe(from: .elementDidAppear)
                }
            case .elementDidDisappear:
                guard event.subject == focus?.entity.element else {
                    break
                }
                let entity = try await AccessEntity(for: event.subject)
                guard let isFocusableAncestor = try await focus?.entity.isInFocusGroup(of: entity),
                      !isFocusableAncestor else {
                    break
                }
                focus = nil
                await refocus(processIdentifier: self.processIdentifier)
            case .elementDidGetFocus:
                guard event.subject != focus?.entity.element else {
                    break
                }
                let newFocus = try await AccessFocus(on: event.subject)
                guard let oldFocus = focus, try await !oldFocus.entity.isInFocusGroup(of: newFocus.entity) else {
                    break
                }
                self.focus = newFocus
//                await readFocus()
            default:
                fatalError("Received an unexpected event notification \(event.notification)")
            }
        } catch {
            await handleError(error)
        }
    }

    /// Handles errors returned by the Element module.
    /// - Parameter error: Error to handle.
    internal func handleError(_ error: any Error) async {
        guard let error = error as? ElementError else {
            fatalError("Unexpected error \(error)")
        }
        switch error {
        case .apiDisabled:
            let content = [OutputSemantic.apiDisabled]
            await Output.shared.convey(content)
        case .invalidElement:
            await refocus(processIdentifier: processIdentifier)
        case .notImplemented:
            let content = [OutputSemantic.notAccessible]
            await Output.shared.convey(content)
        case .timeout:
            let content = [OutputSemantic.timeout]
            await Output.shared.convey(content)
        default:
            logger.warning("Unexpected error \(error, privacy: .public)")
            return
        }
    }
}
